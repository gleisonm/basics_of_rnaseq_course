---
title: "Untitled"
format: html
editor: source
---

```{r}
suppressPackageStartupMessages( {
  library(DESeq2)
  library(dplyr)
  library(tidyverse)
  library(PCAtools)
  library(ggplot2)
  library(pheatmap)
  library(clusterProfiler)
} )
```

```{r}
gene_count <- read.csv("data_pratica/GSE60450_Lactation-GenewiseCounts.txt")[,-1]
gene_count <- column_to_rownames(gene_count,"EntrezGeneID") |>
  select(-Length)

metadata <- read.csv("data_pratica/SampleInfo_Corrected.txt", sep = "\t")
rownames(metadata) <- metadata$SampleName
```

```{r}
dds <- DESeqDataSetFromMatrix(gene_count,
                                colData = metadata,
                                design = ~ CellType + Status)

dds_vst <- vst(dds)
dds <- DESeq(dds)
```

```{r}
counts_genes_vst <- assay(dds_vst)
pca <- pca(counts_genes_vst, metadata = metadata)
biplot(pca, colby = "CellType", shape = "Status", legendPosition = "left")
```


```{r}
res_dge <- DESeq2::results(dds, contrast = c("Status", "lactate", "pregnant"))
res_dge <- as.data.frame(res_dge)

res_dge <- res_dge %>% 
  mutate(
    padj = ifelse(is.na(padj), 1, padj),
    signif = 
      case_when(
        padj <= 0.001 & log2FoldChange < 0 ~ "Downregulated",
        padj <= 0.001 & log2FoldChange > 0 ~ "Upregulated",
        padj > 0.001 ~ "Not significant"
      )
  )

# Filtrar os genes diferencialmente expressos (padj <= 0.05) 
res_dge <- subset(res_dge, padj <= 0.01)

# Selecionar os genes DGE
dge <- rownames(res_dge)

# Obter tabela de expressão 
exp_genes <- DESeq2::counts(dds, normalized = TRUE)

# Desta tabela, verificar quais genes são DGE
idx <- rownames(exp_genes) %in% dge
exp_dge <- exp_genes[idx,]

# Transformar valores de expressão em z-score
exp_dge_z_score <- t(apply(exp_dge, 1, scale, center = T, scale = T))
colnames(exp_dge_z_score) <- rownames(metadata)

# Criar coluna de anotação
ann_col <- as.data.frame(colData(dds)[, c("CellType", "Status")])

# Plotar gráfico
pheatmap(exp_dge_z_score, show_rownames = F, annotation_col = ann_col, cluster_cols = F)
```


```{r}
# meta_lum <- subset(metadata, CellType == "luminal")
# count_lum <- select(gene_count, meta_lum$SampleName)

```

```{r}
# dds <- DESeqDataSetFromMatrix(count_lum,
#                                 colData = meta_lum,
#                                 design = ~ CellType )
# 
# dds_vst <- vst(dds)
# dds <- DESeq(dds)
```
```{r}
# counts_genes_vst <- assay(dds_vst)
# pca <- pca(counts_genes_vst, metadata = meta_lum)
# biplot(pca, colby = "CellType", shape = "Status", legendPosition = "left")
```

```{r}
# res_dge <- DESeq2::results(dds, contrast = c("Status", "lactate", "virgin"))
# res_dge <- as.data.frame(res_dge)
```

```{r}
res_dge <- res_dge %>% 
  mutate(
    padj = ifelse(is.na(padj), 1, padj),
    signif = 
      case_when(
        padj <= 0.001 & log2FoldChange < 0 ~ "Downregulated",
        padj <= 0.001 & log2FoldChange > 0 ~ "Upregulated",
        padj > 0.001 ~ "Not significant"
      )
  )

ggplot(res_dge, aes(x = log2FoldChange, y = -log10(padj), color = signif)) +
  geom_point() +
  scale_color_manual(values = c("Downregulated" = "blue", "Not significant" = "grey", "Upregulated" = "red"))
```

```{r}
# Filtrar os genes diferencialmente expressos (padj <= 0.05) 
res_dge <- subset(res_dge, padj <= 0.001)

# Selecionar os genes DGE
dge <- rownames(res_dge)

# Obter tabela de expressão 
exp_genes <- DESeq2::counts(dds, normalized = TRUE)

# Desta tabela, verificar quais genes são DGE
idx <- rownames(exp_genes) %in% dge
exp_dge <- exp_genes[idx,]

# Transformar valores de expressão em z-score
exp_dge_z_score <- t(apply(exp_dge, 1, scale, center = T, scale = T))
colnames(exp_dge_z_score) <- rownames(metadata)
#colnames(exp_dge_z_score) <- rownames(meta_lum)

# Criar coluna de anotação
ann_col <- as.data.frame(colData(dds)[, c("Status", "CellType")])

# Plotar gráfico
pheatmap(exp_dge_z_score, show_rownames = F, annotation_col = ann_col, cluster_cols = F)
```
```{r}
res_dge
```

```{r}
library(clusterProfiler)

# 1. Preparar as listas de genes (Entrez IDs)
# Como seus rownames já são Entrez IDs, basta filtrar
genes_up <- rownames(subset(res_dge, signif == "Upregulated"))
genes_down <- rownames(subset(res_dge, signif == "Downregulated"))

# 2. Criar uma lista nomeada para o clusterProfiler
lista_genes <- list(
  Upregulated = genes_up,
  Downregulated = genes_down
)

# 3. Rodar o CompareCluster (Enriquecimento KEGG)
# organism = "mmu" para camundongo (use "hsa" se fosse humano)
kegg_compare <- compareCluster(geneCluster = lista_genes, 
                               fun = "enrichKEGG", 
                               organism = "mmu",
                               pvalueCutoff = 0.05)

kegg_compare@compareClusterResult <- kegg_compare@compareClusterResult %>%
  filter(category != "Human Diseases")

# Para Upregulated
kegg_up <- enrichKEGG(gene = genes_up, organism = 'mmu', pvalueCutoff = 0.05)

kegg_up@result <- kegg_up@result %>%
  filter(category != "Human Diseases")

# Para Downregulated
kegg_down <- enrichKEGG(gene = genes_down, organism = 'mmu', pvalueCutoff = 0.05)

kegg_down@result <- kegg_down@result %>%
  filter(category != "Human Diseases")

# Visualizar


# 4. Visualizar os resultados
# O x="Cluster" separa as colunas em Upregulated e Downregulated
dotplot(kegg_compare, showCategory = 10, title = "KEGG Enrichment: Lactate vs Virgin") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
dotplot(kegg_up, title = "KEGG Up")

```

```{r}
dotplot(kegg_down, title = "KEGG Down")

```

```{r}
library(RCurl)

# 1. Preparar os genes de entrada
# Vamos pegar os genes diferencialmente expressos que definimos antes (variável 'dge')
# Se a lista for muito grande (>2000), o STRING pode reclamar. 
# Aqui assumo que 'dge' contém os IDs dos genes significativos (Entrez IDs)
genes_input <- rownames(res_dge) 
genes_concatenado <- paste0(genes_input, collapse = "%0d")

# 2. Mapear IDs para o formato do STRING
# Importante: species = "10090" (Mouse)
req <- RCurl::postForm(
  "https://string-db.org/api/tsv/get_string_ids",
  identifiers = genes_concatenado,
  echo_query = "1",
  species = "10090" 
)

map_ids <- read.table(text = req, sep = "\t", header = T, quote = "")

# Dica: Verifique se houve mapeamento
print(paste("Genes mapeados:", nrow(map_ids)))

# 3. Obter a rede de interação
# Concatenar os identificadores STRING obtidos



genes_string_concatenado <- paste0(unique(map_ids$stringId), collapse = "%0d")



# Requisição para o método 'network'
# Importante: species = "10090"
req2 <- RCurl::postForm(
  "https://string-db.org/api/tsv/network",
  identifiers = genes_string_concatenado, 
  required_core = "0", 
  species = "10090" 
)

int_network <- read.table(text = req2, sep = "\t", header = T)
int_network <- unique(int_network)

# 4. Definir a função de combinação de scores (igual ao seu exemplo)
combinescores <- function(dat, evidences = "all", confLevel = 0.4) {
  if(evidences[1] == "all"){
    edat<-dat[,-c(1,2,ncol(dat))]
  } else {
    if(!all(evidences%in%colnames(dat))){
      stop("NOTE: one or more 'evidences' not listed in 'dat' colnames!")
    }
    edat<-dat[,evidences]
  }
  if (any(edat > 1)) {
    edat <- edat/1000
  }
  edat<-1-edat
  sc<- apply(X = edat, MARGIN = 1, FUN = function(x) 1-prod(x))
  dat <- cbind(dat[,c(1,2)],combined_score = sc)
  idx <- dat$combined_score >= confLevel
  dat <-dat[idx,]
  return(dat)
}

# 5. Filtrar e Calcular o Score Final
# Usando as mesmas evidências (co-expressão, experimental, banco de dados) e corte de 0.9
int_network_final <- combinescores(int_network, 
                                   evidences = c("ascore", "escore", "dscore"), 
                                   confLevel = 0.9)

# Visualizar o resultado
head(int_network_final)
```

```{r}
# Exemplo rápido de visualização no R
library(igraph)
rede_igraph <- graph_from_data_frame(int_network_final, directed = FALSE)
plot(rede_igraph, 
     vertex.size = 5, 
     vertex.label = NA, # Remove nomes para não poluir se for grande
     main = "Rede de Interação (STRING High Confidence)")
```

